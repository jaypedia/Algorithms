// Recursion & Call Stack
// 2021-11-24

// 재귀 함수 : 함수가 스스로를 호출하는 것

// ****************************** 기본 단계와 재귀 단계 ***************************************
// 모든 재귀 함수는 기본 단계와 재귀 단계로 나눌 수 있다.
// 기본 단계 : 함수가 자기 자신을 다시 호출하지 않는 경우, 즉 무한 반복으로 빠져들지 않게 하는 부분
// 재귀 단계 : 함수가 자기 자신을 호출하는 부분
function countdown(i) {
  console.log(i);

  // 기본 단계 - Terminating case 종결 조건 이라고도 함.
  if (i <= 1) return;
  // 재귀 단계
  else countdown(i - 1);
}

countdown(10);

// ****************************** 호출 스택 ******************************
// 모든 함수 호출은 call stack을 사용한다.
// stack에는 push, pop 두 가지 연산이 있다.
function greet(name) {
  console.log(`Hello, ${name}!`);
  greet2(name);
  console.log('getting ready to say bye...');
  bye();
}

function greet2(name) {
  console.log(`How are you, ${name}?`);
}

function bye() {
  console.log('Ok, bye!');
}

greet('Miille');
// 1. 컴퓨터는 함수 호출을 위해 메모리를 할당한다.
// 2. name이라는 변수(파라미터)의 값이 "Millie"가 되었으므로, 이 값을 메모리에 저장한다.
// 3. "Hello, Millie!"를 프린트한 후 greet2("Millie") 명령으로 다른 함수를 호출한다. 이번에도 컴퓨터는 함수 호출에 필요한 다른 메모리를 할당한다.
// 컴퓨터는 이러한 메모리를 stack으로 사용한다.
// 즉, greet() 함수 위에 greet2() 함수가 쌓여진 형태이다.
// 4. greet2("Millie") 함수를 호출했으므로 "How are you, Millie?" 를 프린트한다. 함수 호출 상태에서 return하여 돌아온다. 함수가 return되면 가장 위에 있던 함수는 pop 연산으로 없어진다.
// 5. 이제 스택에서 가장 위에 있는 함수는 greet() 함수이다. - 1~4처럼 어떤 함수를 호출하여 완전히 실행을 완료하기 전이라도, 그 함수를 잠시 멈추고 다른 함수를 호출할 수 있다.
// 즉, greet2()의 실행을 완료하고 나면 greet() 함수로 돌아가 멈췄던 위치에서 다시 실행할 수 있다.
// 6. "getting ready to say bye..."를 프린트한 후, bye() 함수를 실행한다.
// 7. 새로운 함수를 위한 메모리가 스택 위에 더해진다.
// 8. 'Ok, bye!'를 프린트한 후 함수 호출 상태에서 return해서 돌아온다.
// 9. 다시 greet() 함수로 돌아왔다. 더 이상 실행할 것이 없으므로 return해서 돌아온다.
// ====> 이런 식으로 여러 개의 함수를 호출하면서 함수에 사용되는 변수(파라미터/인자)를 저장하는 스택을 call stack이라고 한다.

// ****************************** 재귀 함수에서의 호출 스택 사용 ******************************
function factorial(x) {
  if (x === 1) return 1;
  else return x * factorial(x - 1);
}

console.log(factorial(3));
// 1. 3 * f(2) ==> f(2)를 호출
// 2. 2 * f(1) ===> f(1)을 호출
// 3. f(1) ===> x가 1이므로 1을 리턴
// 1 리턴
// 1 * 2 === 2 리턴
// 1 * 2 * 3 === 6 리턴
// 리턴할 때는 스택에서 pop 되는 순서대로 리턴된다.
// fact 함수에 대한 각각의 호출이 자기만의 x값의 사본을 가지고 있다.
// 서로 다른 함수 호출에 대한 x값에 접근할 수 없다.

// 스택은 재귀에서 큰 역할을 한다.
// 함수가 한 번씩 호출될 때마다 함수의 입력값(매개변수), 결과값(리턴값), 그리고 리턴 후 돌아갈 위치 등이 스택(Stack)이라는 데이터 저장 공간에 보관된다.

// ******************************
// 스택을 사용하면 편리하지만, 모든 정보를 저장해야 하므로 메모리를 많이 소비한다.
// 시간 복잡도도 높다.
// 함수 호출을 할 때마다 메모리를 사용하게 된다.
// 스택이 너무 커졌다는 것은 컴퓨터가 과다한 함수 호출 정보를 저장하고 있다는 뜻이다.
// 해결책 1. 재귀 대신 반복문을 쓴다.
// 해결책 2. tail recursion이라는 방법을 사용할 수 있다. 고급 재귀 방법으로, 모든 프로그래밍 언어에서 지원하는 것은 아니다.

// 재귀 함수로 중첩된 배열 탐색하기
